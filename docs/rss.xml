<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Blog</title><link>https://collar2023.github.io/collar.github.io</link><description>AI&amp;BLK</description><copyright>Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://collar2023.github.io/collar.github.io</link></image><lastBuildDate>Sun, 23 Jun 2024 12:31:22 +0000</lastBuildDate><managingEditor>Blog</managingEditor><ttl>60</ttl><webMaster>Blog</webMaster><item><title>Token</title><link>https://collar2023.github.io/collar.github.io/post/Token.html</link><description>pragma solidity ^0.8.4;&#13;
&#13;
// 引入ERC20接口&#13;
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';&#13;
&#13;
// 实现ERC20接口&#13;
contract MyToken is IERC20 {&#13;
    // 定义映射存储账户余额&#13;
    mapping(address =&gt; uint256) private _balances;&#13;
    &#13;
    // 记录代币总供应量&#13;
    uint256 private _totalSupply;&#13;
    &#13;
    // 映射存储账户的允许额度，用于转账授权&#13;
    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;&#13;
    &#13;
    // 代币名称&#13;
    string private _name = 'MyToken';&#13;
    &#13;
    // 代币符号&#13;
    string private _symbol = 'MTK';&#13;
    &#13;
    // 小数位数&#13;
    uint8 private _decimals = 18;&#13;
    &#13;
    // 构造函数，初始化代币总供应量和分配给合约创建者的代币&#13;
    constructor(uint256 initialSupply) {&#13;
        _totalSupply = initialSupply;&#13;
        _balances[msg.sender] = initialSupply;&#13;
        emit Transfer(address(0), msg.sender, initialSupply);&#13;
    }&#13;
    &#13;
    // 返回代币总供应量&#13;
    function totalSupply() public view override returns (uint256) {&#13;
        return _totalSupply;&#13;
    }&#13;
    &#13;
    // 返回指定地址的代币余额&#13;
    function balanceOf(address account) public view override returns (uint256) {&#13;
        return _balances[account];&#13;
    }&#13;
    &#13;
    // 转账函数&#13;
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {&#13;
        _transfer(msg.sender, recipient, amount);&#13;
        return true;&#13;
    }&#13;
    &#13;
    // 内部转账函数，减少发送者余额，增加接收者余额，并触发Transfer事件&#13;
    function _transfer(address sender, address recipient, uint256 amount) internal {&#13;
        require(sender != address(0), 'ERC20: transfer from the zero address');&#13;
        require(recipient != address(0), 'ERC20: transfer to the zero address');&#13;
        require(_balances[sender] &gt;= amount, 'ERC20: transfer amount exceeds balance');&#13;
        _balances[sender] -= amount;&#13;
        _balances[recipient] += amount;&#13;
        emit Transfer(sender, recipient, amount);&#13;
    }&#13;
    &#13;
    // 允许另一个地址代为花费自己的代币&#13;
    function approve(address spender, uint256 amount) public virtual override returns (bool) {&#13;
        _approve(msg.sender, spender, amount);&#13;
        return true;&#13;
    }&#13;
    &#13;
    // 内部批准函数，设置_spender可以从_owner账户转移的代币数量&#13;
    function _approve(address owner, address spender, uint256 amount) internal {&#13;
        require(owner != address(0), 'ERC20: approve from the zero address');&#13;
        require(spender != address(0), 'ERC20: approve to the zero address');&#13;
        _allowances[owner][spender] = amount;&#13;
        emit Approval(owner, spender, amount);&#13;
    }&#13;
    &#13;
    // 返回_spender从_owner账户中可转移的代币数量&#13;
    function allowance(address owner, address spender) public view virtual override returns (uint256) {&#13;
        return _allowances[owner][spender];&#13;
    }&#13;
    &#13;
    // 通过审批过的额度进行转账&#13;
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {&#13;
        _transfer(sender, recipient, amount);&#13;
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);&#13;
        return true;&#13;
    }&#13;
    &#13;
    // 发送Transfer事件&#13;
    event Transfer(address indexed from, address indexed to, uint256 value);&#13;
    &#13;
    // 发送Approval事件&#13;
    event Approval(address indexed owner, address indexed spender, uint256 value);&#13;
}。</description><guid isPermaLink="true">https://collar2023.github.io/collar.github.io/post/Token.html</guid><pubDate>Sat, 22 Jun 2024 11:24:35 +0000</pubDate></item><item><title>AI&amp;BLK</title><link>https://collar2023.github.io/collar.github.io/post/AI%26BLK.html</link><description>AI拓展生产力；BLK重塑生产关系。</description><guid isPermaLink="true">https://collar2023.github.io/collar.github.io/post/AI%26BLK.html</guid><pubDate>Sat, 22 Jun 2024 07:58:38 +0000</pubDate></item></channel></rss>